@page "/OpenFile"
@using KristofferStrube.Blazor.WebIDL.Exceptions;
@inject IFileSystemAccessServiceInProcess FileSystemAccessService

<PageTitle>File System Access - Read File</PageTitle>


@if (errorMessage is not null)
{
    <div class="alert alert-danger">@errorMessage</div>
}
@if (fileHandle is null)
{
    <p>
        The browser can remember a set of previously used folders given an id. If a prompt has never been opened with this id then it falls back to using the well-known directory and the folder that is used this time is remembered for the next time the id is used. The id must only contain alphanumeric sumbols or "_" or "-" and cannot be longer than 32 characters.
        <br />
        You can specify an id below here or leave it blank. You can try to give it some illegal characters or make it too long to see that we can handle errors of this type.
        <br />
        We can likewise detect if the user aborts the prompt which you can also test here by canceling or closing the prompt.
    </p>
    <label for="id">Id: </label> <input @bind="id" type="text" id="id" />
    <br />
    <br />
    <button @onclick="OpenFilePicker" class="btn btn-primary">Open File Picker for Single File</button>
}
else if (readPermissionState is PermissionState.Denied)
{
    <button @onclick="RequestReadAccess" class="btn btn-primary">Request Read Access for @fileHandle.Name</button>
}
else if (fileText is null)
{
    <button @onclick="ReadFile" class="btn btn-primary">Read @fileHandle.Name</button>
}
else if (writePermissionState is PermissionState.Denied or PermissionState.Prompt)
{
    <button @onclick="RequestWriteAccess" class="btn btn-primary">Request Write Access for @fileHandle.Name</button>
    <textarea style="width:100%;height:calc(100% - 44px);" value=@fileText @oninput=TextAreaChanged disabled="disabled"></textarea>
}
else
{
    <textarea style="width:100%;height:calc(100% - 6px);" value=@fileText @oninput=TextAreaChanged></textarea>
}

@code {
    private string? fileText;
    private string? errorMessage;
    private string? id;
    private FileSystemFileHandleInProcess? fileHandle;
    private PermissionState readPermissionState;
    private PermissionState writePermissionState;

    private async Task OpenFilePicker()
    {
        try
        {
            var options = new OpenFilePickerOptionsStartInWellKnownDirectory() { Multiple = false, StartIn = WellKnownDirectory.Downloads, Id = id };
            var fileHandles = await FileSystemAccessService.ShowOpenFilePickerAsync(options);
            fileHandle = fileHandles.Single();
        }
        catch (AbortErrorException)
        {
            errorMessage = $"The user aborted the prompt.";
        }
        catch (DOMException ex)
        {
            errorMessage = $"A user interaction error of type {ex.Name} occurred: \"{ex.Message}\"";
        }
        catch (TypeErrorException ex)
        {
            errorMessage = $"We parsed an invalid argument to the function: \"{ex.Message}\"";
        }
        catch (Exception ex)
        {
            errorMessage = $"Some other unexpected exception of type {ex.GetType().Name} occurred: \"{ex.Message}\"";
        }
        finally
        {
            if (fileHandle != null)
            {
                errorMessage = null;
                readPermissionState = await fileHandle.QueryPermissionAsync(new() { Mode = FileSystemPermissionMode.Read });
            }
        }
    }

    private async Task RequestReadAccess()
    {
        if (fileHandle is null) return;
        readPermissionState = await fileHandle.RequestPermissionAsync(new() { Mode = FileSystemPermissionMode.Read });
    }

    private async Task ReadFile()
    {
        if (fileHandle is null) return;
        Console.WriteLine($"Name: {fileHandle.Name}");
        Console.WriteLine($"Kind: {fileHandle.Kind}");
        Console.WriteLine($"Is Same as Self: {await fileHandle.IsSameEntryAsync(fileHandle)}");
        var file = await fileHandle.GetFileAsync();
        Console.WriteLine($"File Name: {file.Name}");
        Console.WriteLine($"File LastModified: {file.LastModified.ToString()}");
        Console.WriteLine($"File Size: {file.Size}");
        Console.WriteLine($"File Type: {file.Type}");
        fileText = await file.TextAsync();
        writePermissionState = await fileHandle.QueryPermissionAsync(new() { Mode = FileSystemPermissionMode.ReadWrite });
    }

    private async Task RequestWriteAccess()
    {
        if (fileHandle is null) return;
        writePermissionState = await fileHandle.RequestPermissionAsync(new() { Mode = FileSystemPermissionMode.ReadWrite });
    }

    private async Task TextAreaChanged(ChangeEventArgs eventArgs)
    {
        if (fileHandle is not null && eventArgs.Value is string value)
        {
            var writable = await fileHandle.CreateWritableAsync();
            await writable.WriteAsync(value);
            await writable.CloseAsync();
        }
    }
}